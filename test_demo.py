# -*- coding: utf-8 -*-
"""
/***************************************************************************
 demoira
                                 A QGIS plugin
 z
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-02-07
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Test
        email                : afrikgeotech@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.core import QgsProject, QgsPoint, QgsGeometry, QgsVectorLayer, QgsFeature, QgsField, QgsWkbTypes, QgsExpression, QgsExpressionContext, QgsExpressionContextUtils
from PyQt5.QtCore import QVariant
from PyQt5.QtWidgets import QListWidgetItem

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .test_demo_dialog import demoiraDialog
import os.path


class demoira:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """

        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'demoira_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&testdemo')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('demoira', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/test_demo/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'test_control'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&testdemo'),
                action)
            self.iface.removeToolBarIcon(action)


    def doublongeom(self):
        # Définition des couches
        couches_linéaires = {
            "Canalisations": self.dlg.mMapLayerComboBox.currentLayer(),
            "Linéaires de branchement": self.dlg.mMapLayerComboBox_2.currentLayer(),
        }
        couches_pontuelles = {
            "Boîtes de branchement": self.dlg.mMapLayerComboBox_5.currentLayer(),
            "Regards": self.dlg.mMapLayerComboBox_3.currentLayer(),
            "Ouvrages": self.dlg.mMapLayerComboBox_4.currentLayer(),
        }

        # Définition des couches temporaires
        uri_lin_double_geom = "LineString?crs=EPSG:2154"
        uri_pt_double_geom = "Point?crs=EPSG:2154"

        doublons_pontuels = QgsVectorLayer(uri_pt_double_geom, "Doublons_pontuels", "memory")
        doublons_linéaires = QgsVectorLayer(uri_lin_double_geom, "Doublons_linéaires", "memory")
        superpositions = QgsVectorLayer(uri_lin_double_geom, "Superpositions", "memory")
        auto_intersections = QgsVectorLayer(uri_lin_double_geom, "Auto_intersections", "memory")

        # Ajout des champs pour identifier la couche source
        for layer in [doublons_pontuels, doublons_linéaires, superpositions, auto_intersections]:
            provider = layer.dataProvider()
            provider.addAttributes([QgsField("couche", QVariant.String), QgsField("id", QVariant.Int)])
            layer.updateFields()

        # Détection des **doublons géométriques ponctuels**
        for nom_couche, couche in couches_pontuelles.items():
            if not couche:
                continue

            geom_dict = {}  
            for feature in couche.getFeatures():
                geom = feature.geometry()
                if geom and not geom.isEmpty():
                    point_wkt = geom.asWkt()
                    if point_wkt in geom_dict:
                        new_feature = QgsFeature()
                        new_feature.setGeometry(geom)
                        new_feature.setAttributes([nom_couche, feature.id()])
                        doublons_pontuels.dataProvider().addFeature(new_feature)
                    else:
                        geom_dict[point_wkt] = feature.id()

        # Détection des **doublons géométriques linéaires**
        for nom_couche, couche in couches_linéaires.items():
            if not couche:
                continue

            extremites_dict = {}  # Dictionnaire avec (X1, Y1, X2, Y2) comme clé
            for feature in couche.getFeatures():
                geom = feature.geometry()
                if not geom or geom.isEmpty():
                    continue

                if geom.isMultipart():
                    line = geom.asMultiPolyline()[0]
                else:
                    line = geom.asPolyline()

                if len(line) < 2:
                    continue

                amont = (line[0].x(), line[0].y())
                aval = (line[-1].x(), line[-1].y())
                cle_extremites = tuple(sorted([amont, aval]))  # On trie pour éviter (A,B) ≠ (B,A)

                if cle_extremites in extremites_dict:
                    new_feature = QgsFeature()
                    new_feature.setGeometry(geom)
                    new_feature.setAttributes([nom_couche, feature.id()])
                    doublons_linéaires.dataProvider().addFeature(new_feature)
                else:
                    extremites_dict[cle_extremites] = feature.id()

        # Détection des **auto-intersections**
        for nom_couche, couche in couches_linéaires.items():
            if not couche:
                continue

            for feature in couche.getFeatures():
                geom = feature.geometry()
                if not geom or geom.isEmpty():
                    continue

                if geom.isMultipart():
                    line = geom.asMultiPolyline()[0]
                else:
                    line = geom.asPolyline()

                if len(line) < 2:
                    continue

                amont = QgsGeometry.fromPointXY(line[0])
                aval = QgsGeometry.fromPointXY(line[-1])

                if amont.intersects(aval):  # Vérifie si l'amont touche l'aval
                    new_feature = QgsFeature()
                    new_feature.setGeometry(geom)
                    new_feature.setAttributes([nom_couche, feature.id()])
                    auto_intersections.dataProvider().addFeature(new_feature)

        # Détection des **superpositions linéaires** (plus de 2 sommets en commun)
        for nom_couche, couche in couches_linéaires.items():
            if not couche:
                continue

            features = list(couche.getFeatures())
            for i in range(len(features)):
                geom1 = features[i].geometry()
                if not geom1 or geom1.isEmpty():
                    continue

                if geom1.isMultipart():
                    line1 = geom1.asMultiPolyline()[0]
                else:
                    line1 = geom1.asPolyline()

                points1 = set((pt.x(), pt.y()) for pt in line1)

                for j in range(i + 1, len(features)):
                    geom2 = features[j].geometry()
                    if not geom2 or geom2.isEmpty():
                        continue

                    if geom2.isMultipart():
                        line2 = geom2.asMultiPolyline()[0]
                    else:
                        line2 = geom2.asPolyline()

                    points2 = set((pt.x(), pt.y()) for pt in line2)

                    # Vérification du nombre de sommets en commun
                    intersections = points1.intersection(points2)
                    if len(intersections) > 2:  # Si plus de 2 sommets sont en commun
                        new_feature = QgsFeature()
                        new_feature.setGeometry(geom1.intersection(geom2))
                        new_feature.setAttributes([nom_couche, features[i].id()])
                        superpositions.dataProvider().addFeature(new_feature)

        # Mise à jour des couches temporaires
        for layer in [doublons_pontuels, doublons_linéaires, superpositions, auto_intersections]:
            layer.updateExtents()

        # Ajout des couches au projet
        if doublons_pontuels.featureCount() > 0:
            QgsProject.instance().addMapLayer(doublons_pontuels)
            print("✅ Couche des doublons ponctuels ajoutée.")
        if doublons_linéaires.featureCount() > 0:
            QgsProject.instance().addMapLayer(doublons_linéaires)
            print("✅ Couche des doublons linéaires ajoutée.")
        if superpositions.featureCount() > 0:
            QgsProject.instance().addMapLayer(superpositions)
            print("✅ Couche des superpositions ajoutée.")
        if auto_intersections.featureCount() > 0:
            QgsProject.instance().addMapLayer(auto_intersections)
            print("✅ Couche des auto-intersections ajoutée.")

        # Résumé des résultats
        if all(layer.featureCount() == 0 for layer in [doublons_pontuels, doublons_linéaires, superpositions, auto_intersections]):
            print("✅ Aucune erreur détectée.")





    
    def geominvetnull(self):
        # Définition des couches
        couches = {
            "Canalisations": self.dlg.mMapLayerComboBox.currentLayer(),
            "Linéaires de branchement": self.dlg.mMapLayerComboBox_2.currentLayer(),
        }
        couches_points = {
            "Boîtes de branchement": self.dlg.mMapLayerComboBox_5.currentLayer(),
            "Regards": self.dlg.mMapLayerComboBox_3.currentLayer(),
            "Ouvrages": self.dlg.mMapLayerComboBox_4.currentLayer(),
        } 

        # Création des couches temporaires
        uri_lin_geom_inv = "LineString?crs=EPSG:2154"
        uri_pt_geom_inv = "Point?crs=EPSG:2154"
        
        geom_lin_invalides = QgsVectorLayer(uri_lin_geom_inv, "Linéaires_invalides", "memory")
        geom_pt_invalides = QgsVectorLayer(uri_pt_geom_inv, "Ponctuels_invalides", "memory")

        # Ajout des champs génériques
        provider_lin = geom_lin_invalides.dataProvider()
        provider_pt = geom_pt_invalides.dataProvider()

        provider_lin.addAttributes([QgsField("couche", QVariant.String), QgsField("id", QVariant.Int)])
        provider_pt.addAttributes([QgsField("couche", QVariant.String), QgsField("id", QVariant.Int)])

        geom_lin_invalides.updateFields()
        geom_pt_invalides.updateFields()

        # Vérification des géométries linéaires
        for nom_couche, couche in couches.items():
            if not couche:
                print(f"La couche {nom_couche} n'est pas sélectionnée.")
                continue

            for feature in couche.getFeatures():
                geom = feature.geometry()
                if not geom or geom.isEmpty() or not geom.isGeosValid():  # ✅ Utiliser isGeosValid()
                    new_feature = QgsFeature()
                    new_feature.setGeometry(geom)  
                    new_feature.setAttributes([nom_couche, feature.id()])
                    provider_lin.addFeature(new_feature)

        # Vérification des géométries ponctuelles
        for nom_couche, couche in couches_points.items():
            if not couche:
                print(f"La couche {nom_couche} n'est pas sélectionnée.")
                continue

            for feature in couche.getFeatures():
                geom = feature.geometry()
                if not geom or geom.isEmpty() or not geom.isGeosValid():  # ✅ Utiliser isGeosValid()
                    new_feature = QgsFeature()
                    new_feature.setGeometry(geom)  
                    new_feature.setAttributes([nom_couche, feature.id()])
                    provider_pt.addFeature(new_feature)

        # Mise à jour des couches
        geom_lin_invalides.updateExtents()
        geom_pt_invalides.updateExtents()

        # Ajouter les couches au projet QGIS
        if geom_lin_invalides.featureCount() > 0:
            QgsProject.instance().addMapLayer(geom_lin_invalides)
            print("✅ Couche des linéaires invalides ajoutée au projet.")
        if geom_pt_invalides.featureCount() > 0:
            QgsProject.instance().addMapLayer(geom_pt_invalides)
            print("✅ Couche des ponctuels invalides ajoutée au projet.")

        # Affichage des résultats
        if geom_lin_invalides.featureCount() == 0 and geom_pt_invalides.featureCount() == 0:
            print("✅ Toutes les géométries sont valides.")





    def control1(self):
        canalisations = self.dlg.mMapLayerComboBox.currentLayer()
        linbranch = self.dlg.mMapLayerComboBox_2.currentLayer()
        boitesbranch = self.dlg.mMapLayerComboBox_5.currentLayer()

        branchements_isoles = []
        champs = linbranch.fields()  # Récupération des champs de la couche d'origine

        # Création de la couche temporaire
        uri = "LineString?crs=EPSG:2154"  # Modifie l'EPSG selon ton projet
        temp_layer = QgsVectorLayer(uri, "branchements_isoles", "memory")
        temp_layer.dataProvider().addAttributes(champs)  # Ajout des mêmes champs que la couche originale
        temp_layer.updateFields()

        for branchement in linbranch.getFeatures():
            geom_branchement = branchement.geometry()

            if not geom_branchement or geom_branchement.isEmpty():
                continue

            if geom_branchement.isMultipart():
                line = geom_branchement.asMultiPolyline()[0]
            else:
                line = geom_branchement.asPolyline()

            if len(line) < 2:
                continue

            start_point = QgsGeometry.fromPointXY(line[0])  # Point amont
            end_point = QgsGeometry.fromPointXY(line[-1])  # Point aval

            # Vérifier si l'amont touche une canalisation
            start_intersecte_cana = any(start_point.intersects(canalisation.geometry()) for canalisation in canalisations.getFeatures())
            # Vérifier si l'aval touche une boîte de branchement
            end_intersecte_boite = any(end_point.intersects(boite.geometry()) for boite in boitesbranch.getFeatures())

            # Vérifier si l'aval touche une canalisation
            end_intersecte_cana = any(end_point.intersects(canalisation.geometry()) for canalisation in canalisations.getFeatures())
            # Vérifier si l'amont touche une boîte de branchement
            start_intersecte_boite = any(start_point.intersects(boite.geometry()) for boite in boitesbranch.getFeatures())

            # Vérification finale : Amont doit toucher canalisation et aval boîte, ou inversement
            branchement_valide = (start_intersecte_cana and end_intersecte_boite) or (end_intersecte_cana and start_intersecte_boite)

            if not branchement_valide:
                branchements_isoles.append(branchement.id())

                # Ajouter l'entité à la couche temporaire
                new_feature = QgsFeature()
                new_feature.setGeometry(geom_branchement)
                new_feature.setAttributes(branchement.attributes())  # Copie les attributs
                temp_layer.dataProvider().addFeature(new_feature)

        temp_layer.updateExtents()

        # Ajouter la couche au projet QGIS
        QgsProject.instance().addMapLayer(temp_layer)

        # Affichage des résultats
        if branchements_isoles:
            print(f"Linéaires de branchement isolés : {branchements_isoles}")
        else:
            print("Tous les branchements sont correctement connectés.")



    def control2(self):
        canalisations = self.dlg.mMapLayerComboBox.currentLayer()
        regards = self.dlg.mMapLayerComboBox_3.currentLayer()

        if not regards or not canalisations:
            print("Erreur : Vérifiez que les couches sont bien sélectionnées.")
            return

        regards_isoles = []
        champs_reg = regards.fields()  # Récupération des champs de la couche d'origine

        # Création de la couche temporaire pour stocker les regards isolés
        uri_reg = "Point?crs=EPSG:2154"  # Modifier l'EPSG selon ton projet
        temp_layer_reg = QgsVectorLayer(uri_reg, "regards_isolés", "memory")
        provider = temp_layer_reg.dataProvider()
        provider.addAttributes(champs_reg)  # Ajout des mêmes champs que la couche originale
        temp_layer_reg.updateFields()

        # Parcourir tous les regards
        for regard in regards.getFeatures():
            geom_regard = regard.geometry()

            if not geom_regard or geom_regard.isEmpty():
                continue

            est_connecte = False  # Flag pour vérifier si le regard est connecté à une canalisation

            # Vérifier si ce regard est à l'extrémité d'une canalisation
            for canalisation in canalisations.getFeatures():
                geom_canalisation = canalisation.geometry()

                if not geom_canalisation or geom_canalisation.isEmpty():
                    continue

                if geom_canalisation.isMultipart():
                    line = geom_canalisation.asMultiPolyline()[0]
                else:
                    line = geom_canalisation.asPolyline()

                if len(line) < 2:
                    continue

                cana_start_point = QgsGeometry.fromPointXY(line[0])
                cana_end_point = QgsGeometry.fromPointXY(line[-1])

                # Vérification si le regard intersecte une des extrémités de la canalisation
                if geom_regard.intersects(cana_start_point) or geom_regard.intersects(cana_end_point):
                    est_connecte = True
                    break  # Sortir dès qu'on trouve une connexion

            if not est_connecte:
                regards_isoles.append(regard.id())

                # Ajouter l'entité à la couche temporaire
                new_feature = QgsFeature()
                new_feature.setGeometry(geom_regard)
                new_feature.setAttributes(regard.attributes())  # Copie les attributs
                provider.addFeature(new_feature)

        temp_layer_reg.updateExtents()

        # Ajouter la couche au projet QGIS
        QgsProject.instance().addMapLayer(temp_layer_reg)

        # Affichage des résultats
        if regards_isoles:
            print(f"Regards isolés : {regards_isoles}")
        else:
            print("Tous les regards sont connectés à une canalisation.")



    def boiteisoles(self):
        linbranch = self.dlg.mMapLayerComboBox_2.currentLayer()
        boitesbranch = self.dlg.mMapLayerComboBox_5.currentLayer()

        if not boitesbranch or not linbranch:
            print("Erreur : Vérifiez que les couches sont bien sélectionnées.")
            return

        bbisoles = []
        champs_bb = boitesbranch.fields()  # Récupération des champs de la couche d'origine

        # Création de la couche temporaire pour stocker les boîtes isolées
        uri_bb = "Point?crs=EPSG:2154"  # Adapter l'EPSG au projet
        temp_layer_bb = QgsVectorLayer(uri_bb, "boites_isolees", "memory")
        provider = temp_layer_bb.dataProvider()
        provider.addAttributes(champs_bb)  # Ajout des mêmes champs que la couche originale
        temp_layer_bb.updateFields()

        # Parcourir toutes les boîtes de branchement
        for boite in boitesbranch.getFeatures():
            geom_boite = boite.geometry()

            if not geom_boite or geom_boite.isEmpty():
                continue

            est_connecte = False  # Flag pour vérifier si la boîte est connectée à une canalisation de branchement

            # Vérifier si la boîte est à l'extrémité d'une canalisation de branchement
            for lineaire_branchement in linbranch.getFeatures():
                geom_lineaire_branchement = lineaire_branchement.geometry()

                if not geom_lineaire_branchement or geom_lineaire_branchement.isEmpty():
                    continue

                if geom_lineaire_branchement.isMultipart():
                    line = geom_lineaire_branchement.asMultiPolyline()[0]
                else:
                    line = geom_lineaire_branchement.asPolyline()

                if len(line) < 2:
                    continue

                cana_start_point = QgsGeometry.fromPointXY(line[0])
                cana_end_point = QgsGeometry.fromPointXY(line[-1])

                # Vérification si la boîte intersecte une des extrémités de la canalisation de branchement
                if geom_boite.intersects(cana_start_point) or geom_boite.intersects(cana_end_point):
                    est_connecte = True
                    break  # Sortir dès qu'on trouve une connexion

            if not est_connecte:
                bbisoles.append(boite.id())

                # Ajouter l'entité à la couche temporaire
                new_feature = QgsFeature()
                new_feature.setGeometry(geom_boite)
                new_feature.setAttributes(boite.attributes())  # Copie les attributs
                provider.addFeature(new_feature)

        temp_layer_bb.updateExtents()

        # Ajouter la couche au projet QGIS
        if bbisoles:
            QgsProject.instance().addMapLayer(temp_layer_bb)
            print(f"✅ {len(bbisoles)} boîtes isolées détectées et ajoutées à la carte.")
        else:
            print("✅ Toutes les boîtes de branchement sont connectées à une canalisation.")



        


    def control3(self):
        canalisations = self.dlg.mMapLayerComboBox.currentLayer()

        if not canalisations:
            print("Erreur : Veuillez sélectionner une couche de canalisations.")
            return

        canalisations_isolées = []
        champs_cana = canalisations.fields()  # Récupération des champs de la couche originale

        # Création de la couche temporaire pour stocker les canalisations isolées
        uri_cana = "LineString?crs=EPSG:2154"  # Modifier l'EPSG selon le projet
        temp_layer_cana = QgsVectorLayer(uri_cana, "canalisations_isolées", "memory")
        provider = temp_layer_cana.dataProvider()
        provider.addAttributes(champs_cana)  # Copie les champs
        temp_layer_cana.updateFields()

        # Stocker les extrémités des canalisations sous forme de dictionnaire {id: (start_point, end_point)}
        extremites_cana = {}

        for canalisation in canalisations.getFeatures():
            geom_cana = canalisation.geometry()
            
            if not geom_cana or geom_cana.isEmpty():
                continue

            if geom_cana.isMultipart():
                line = geom_cana.asMultiPolyline()[0]
            else:
                line = geom_cana.asPolyline()

            if len(line) < 2:
                continue

            cana_start_point = QgsGeometry.fromPointXY(line[0])
            cana_end_point = QgsGeometry.fromPointXY(line[-1])

            extremites_cana[canalisation.id()] = (cana_start_point, cana_end_point)

        # Vérification de la connexion des extrémités entre les canalisations
        for cana_id, (start_geom, end_geom) in extremites_cana.items():
            est_connecte = False

            for autre_id, (autre_start, autre_end) in extremites_cana.items():
                if cana_id == autre_id:
                    continue  # Ne pas comparer une canalisation avec elle-même

                # Vérifier si une extrémité touche une extrémité d'une autre canalisation
                if start_geom.intersects(autre_start) or start_geom.intersects(autre_end) or \
                end_geom.intersects(autre_start) or end_geom.intersects(autre_end):
                    est_connecte = True
                    break  # Pas besoin de continuer à vérifier cette canalisation

            if not est_connecte:
                canalisations_isolées.append(cana_id)

                # Ajouter l'entité à la couche temporaire
                new_feature = QgsFeature()
                new_feature.setGeometry(canalisations.getFeature(cana_id).geometry())
                new_feature.setAttributes(canalisations.getFeature(cana_id).attributes())  # Copie les attributs
                provider.addFeature(new_feature)

        temp_layer_cana.updateExtents()

        # Ajouter la couche au projet QGIS
        QgsProject.instance().addMapLayer(temp_layer_cana)

        # Affichage des résultats
        if canalisations_isolées:
            print(f"Canalisations isolées : {canalisations_isolées}")
        else:
            print("Toutes les canalisations sont connectées.")

            



    def ecoulement(self):
        """Vérifie le sens d'écoulement des canalisations en fonction du champ radier des regards."""
        canalisations = self.dlg.mMapLayerComboBox.currentLayer()
        regards = self.dlg.mMapLayerComboBox_3.currentLayer()
        cote_rad = self.dlg.mFieldComboBox.currentField()  # Champ radier sélectionné
        id_cana = self.dlg.mFieldComboBox_2.currentField()  # Identifiant unique des canalisations

        if not canalisations or not regards or not cote_rad or not id_cana:
            print("Erreur : Vérifiez que toutes les couches et champs sont bien sélectionnés.")
            return

        cana_mal_oriente = []
        champs_cana = canalisations.fields()  # Récupération des champs de la couche originale

        # Création de la couche temporaire pour stocker les canalisations avec un mauvais sens d'écoulement
        uri_cana_ecoulement = "LineString?crs=EPSG:2154"  # Modifier l'EPSG selon le projet
        temp_layer_cana = QgsVectorLayer(uri_cana_ecoulement, "ecoulement_incorrect", "memory")
        provider = temp_layer_cana.dataProvider()
        provider.addAttributes(champs_cana)  # Copie les champs
        temp_layer_cana.updateFields()

        # Stocker les extrémités des canalisations sous forme de dictionnaire {id: (start_point, end_point)}
        extremites_cana = {}

        for canalisation in canalisations.getFeatures():
            geom_cana = canalisation.geometry()

            if not geom_cana or geom_cana.isEmpty():
                continue

            if geom_cana.isMultipart():
                line = geom_cana.asMultiPolyline()[0]
            else:
                line = geom_cana.asPolyline()

            if len(line) < 2:
                continue

            cana_start_point = QgsGeometry.fromPointXY(line[0])
            cana_end_point = QgsGeometry.fromPointXY(line[-1])

            extremites_cana[canalisation[id_cana]] = (cana_start_point, cana_end_point)

        # Vérifier le sens d'écoulement en croisant les extrémités avec les regards
        for canalisation_id, (start_geom, end_geom) in extremites_cana.items():
            radier_amont = None
            radier_aval = None

            for regard in regards.getFeatures():
                regard_geom = regard.geometry()

                if regard_geom and not regard_geom.isEmpty():
                    if start_geom.intersects(regard_geom):
                        radier_amont = regard[cote_rad]
                    elif end_geom.intersects(regard_geom):
                        radier_aval = regard[cote_rad]

            if radier_amont is not None and radier_aval is not None:
                if radier_amont < radier_aval:  # Sens d'écoulement incorrect
                    cana_mal_oriente.append(canalisation_id)

        # Ajouter les canalisations mal orientées à la couche temporaire
        for canalisation in canalisations.getFeatures():
            if canalisation[id_cana] in cana_mal_oriente:
                new_feature = QgsFeature()
                new_feature.setGeometry(canalisation.geometry())
                new_feature.setAttributes(canalisation.attributes())  # Copie les attributs
                provider.addFeature(new_feature)

        temp_layer_cana.updateExtents()

        # Ajouter la couche au projet QGIS
        QgsProject.instance().addMapLayer(temp_layer_cana)

        # Affichage des résultats
        if cana_mal_oriente:
            print(f"Canalisations mal orientées : {cana_mal_oriente}")
        else:
            print("Toutes les canalisations respectent le sens d'écoulement.")


    def update_field_list(self):
        """Met à jour QListWidget avec les champs de la couche sélectionnée"""
        
        layer_classe = self.dlg.mMapLayerComboBox_6.currentLayer()
        
        if not layer_classe:
            print("Erreur : Aucune couche sélectionnée.")
            return
        
        # Vider la liste avant de la remplir à nouveau
        self.dlg.listWidget.clear()

        # Ajouter les noms de champs
        for field in layer_classe.fields():
            item = QListWidgetItem(field.name())  # Créer un élément de liste
            item.setCheckState(Qt.Unchecked)  # Permet de cocher/décocher les champs
            self.dlg.listWidget.addItem(item)

        print(f"📌 {self.dlg.listWidget.count()} champs affichés dans QListWidget.")

    
    def set_attributes(self):
        # Vider la liste des attributs affichés
        self.dlg.attributes.clear()

        # Récupérer la couche sélectionnée
        couche_classe_a = self.dlg.mMapLayerComboBox_6.currentLayer()

        if couche_classe_a is None:
            return  # Sortir si aucune couche sélectionnée

        # Ajouter les noms des champs au widget QListWidget ou QComboBox
        for field in couche_classe_a.fields():
            self.dlg.attributes.addItem(field.name())  # Assure-toi que `attributes` est défini

        # Vérifier le séparateur décimal selon la locale
        if self.locale().decimalPoint() == '.':
            self.dlg.decimal_mark.setCurrentIndex(self.dlg.decimal_mark.findText("(period)"))
            self.dlg.field_delimiter.setCurrentIndex(self.dlg.field_delimiter.findText("(comma)"))
        else:
            self.dlg.decimal_mark.setCurrentIndex(self.dlg.decimal_mark.findText("(comma)"))
            self.dlg.field_delimiter.setCurrentIndex(self.dlg.field_delimiter.findText("(semicolon)"))















        
    def run_all_controls(self):
        self.control1()
        self.control2()
        self.control3()
        self.geominvetnull()
        self.doublongeom()
        self.set_attributes()
        self.dlg.mMapLayerComboBox_6.currentIndexChanged.connect(self.set_attributes)


    def run(self):
        """Run method that performs all the real work"""
        #self.dlg.mMapLayerComboBox_6.currentIndexChanged.connect(self.update_field_list)

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = demoiraDialog()

            # Connexion après la création de l'interface
            self.dlg.but.clicked.connect(self.control1)
            self.dlg.but_2.clicked.connect(self.control2)
            self.dlg.but_3.clicked.connect(self.control3)
            self.dlg.but_4.clicked.connect(self.geominvetnull)
            self.dlg.but_5.clicked.connect(self.doublongeom)
            self.dlg.ecoul.clicked.connect(self.ecoulement)
            #self.dlg.classe.clicked.connect(self.verifclassea)

            # Exécuter tous les controles 
            self.dlg.allcontrol.clicked.connect(self.run_all_controls)

        self.dlg.but.setEnabled(True)
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass



