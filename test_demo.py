# -*- coding: utf-8 -*-
"""
/***************************************************************************
 demoira
                                 A QGIS plugin
 z
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-02-07
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Test
        email                : afrikgeotech@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.core import QgsProject, QgsPoint, QgsGeometry, QgsVectorLayer, QgsFeature, QgsField, QgsWkbTypes, QgsExpression, QgsExpressionContext, QgsExpressionContextUtils
from PyQt5.QtCore import QVariant
from PyQt5.QtWidgets import QListWidgetItem

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .test_demo_dialog import demoiraDialog
import os.path


class demoira:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """

        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'demoira_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&testdemo')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('demoira', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/test_demo/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'test_control'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&testdemo'),
                action)
            self.iface.removeToolBarIcon(action)


    def doublongeom(self):
        # D√©finition des couches
        couches_lin√©aires = {
            "Canalisations": self.dlg.mMapLayerComboBox.currentLayer(),
            "Lin√©aires de branchement": self.dlg.mMapLayerComboBox_2.currentLayer(),
        }
        couches_pontuelles = {
            "Bo√Ætes de branchement": self.dlg.mMapLayerComboBox_5.currentLayer(),
            "Regards": self.dlg.mMapLayerComboBox_3.currentLayer(),
            "Ouvrages": self.dlg.mMapLayerComboBox_4.currentLayer(),
        }

        # D√©finition des couches temporaires
        uri_lin_double_geom = "LineString?crs=EPSG:2154"
        uri_pt_double_geom = "Point?crs=EPSG:2154"

        doublons_pontuels = QgsVectorLayer(uri_pt_double_geom, "Doublons_pontuels", "memory")
        doublons_lin√©aires = QgsVectorLayer(uri_lin_double_geom, "Doublons_lin√©aires", "memory")
        superpositions = QgsVectorLayer(uri_lin_double_geom, "Superpositions", "memory")
        auto_intersections = QgsVectorLayer(uri_lin_double_geom, "Auto_intersections", "memory")

        # Ajout des champs pour identifier la couche source
        for layer in [doublons_pontuels, doublons_lin√©aires, superpositions, auto_intersections]:
            provider = layer.dataProvider()
            provider.addAttributes([QgsField("couche", QVariant.String), QgsField("id", QVariant.Int)])
            layer.updateFields()

        # D√©tection des **doublons g√©om√©triques ponctuels**
        for nom_couche, couche in couches_pontuelles.items():
            if not couche:
                continue

            geom_dict = {}  
            for feature in couche.getFeatures():
                geom = feature.geometry()
                if geom and not geom.isEmpty():
                    point_wkt = geom.asWkt()
                    if point_wkt in geom_dict:
                        new_feature = QgsFeature()
                        new_feature.setGeometry(geom)
                        new_feature.setAttributes([nom_couche, feature.id()])
                        doublons_pontuels.dataProvider().addFeature(new_feature)
                    else:
                        geom_dict[point_wkt] = feature.id()

        # D√©tection des **doublons g√©om√©triques lin√©aires**
        for nom_couche, couche in couches_lin√©aires.items():
            if not couche:
                continue

            extremites_dict = {}  # Dictionnaire avec (X1, Y1, X2, Y2) comme cl√©
            for feature in couche.getFeatures():
                geom = feature.geometry()
                if not geom or geom.isEmpty():
                    continue

                if geom.isMultipart():
                    line = geom.asMultiPolyline()[0]
                else:
                    line = geom.asPolyline()

                if len(line) < 2:
                    continue

                amont = (line[0].x(), line[0].y())
                aval = (line[-1].x(), line[-1].y())
                cle_extremites = tuple(sorted([amont, aval]))  # On trie pour √©viter (A,B) ‚â† (B,A)

                if cle_extremites in extremites_dict:
                    new_feature = QgsFeature()
                    new_feature.setGeometry(geom)
                    new_feature.setAttributes([nom_couche, feature.id()])
                    doublons_lin√©aires.dataProvider().addFeature(new_feature)
                else:
                    extremites_dict[cle_extremites] = feature.id()

        # D√©tection des **auto-intersections**
        for nom_couche, couche in couches_lin√©aires.items():
            if not couche:
                continue

            for feature in couche.getFeatures():
                geom = feature.geometry()
                if not geom or geom.isEmpty():
                    continue

                if geom.isMultipart():
                    line = geom.asMultiPolyline()[0]
                else:
                    line = geom.asPolyline()

                if len(line) < 2:
                    continue

                amont = QgsGeometry.fromPointXY(line[0])
                aval = QgsGeometry.fromPointXY(line[-1])

                if amont.intersects(aval):  # V√©rifie si l'amont touche l'aval
                    new_feature = QgsFeature()
                    new_feature.setGeometry(geom)
                    new_feature.setAttributes([nom_couche, feature.id()])
                    auto_intersections.dataProvider().addFeature(new_feature)

        # D√©tection des **superpositions lin√©aires** (plus de 2 sommets en commun)
        for nom_couche, couche in couches_lin√©aires.items():
            if not couche:
                continue

            features = list(couche.getFeatures())
            for i in range(len(features)):
                geom1 = features[i].geometry()
                if not geom1 or geom1.isEmpty():
                    continue

                if geom1.isMultipart():
                    line1 = geom1.asMultiPolyline()[0]
                else:
                    line1 = geom1.asPolyline()

                points1 = set((pt.x(), pt.y()) for pt in line1)

                for j in range(i + 1, len(features)):
                    geom2 = features[j].geometry()
                    if not geom2 or geom2.isEmpty():
                        continue

                    if geom2.isMultipart():
                        line2 = geom2.asMultiPolyline()[0]
                    else:
                        line2 = geom2.asPolyline()

                    points2 = set((pt.x(), pt.y()) for pt in line2)

                    # V√©rification du nombre de sommets en commun
                    intersections = points1.intersection(points2)
                    if len(intersections) > 2:  # Si plus de 2 sommets sont en commun
                        new_feature = QgsFeature()
                        new_feature.setGeometry(geom1.intersection(geom2))
                        new_feature.setAttributes([nom_couche, features[i].id()])
                        superpositions.dataProvider().addFeature(new_feature)

        # Mise √† jour des couches temporaires
        for layer in [doublons_pontuels, doublons_lin√©aires, superpositions, auto_intersections]:
            layer.updateExtents()

        # Ajout des couches au projet
        if doublons_pontuels.featureCount() > 0:
            QgsProject.instance().addMapLayer(doublons_pontuels)
            print("‚úÖ Couche des doublons ponctuels ajout√©e.")
        if doublons_lin√©aires.featureCount() > 0:
            QgsProject.instance().addMapLayer(doublons_lin√©aires)
            print("‚úÖ Couche des doublons lin√©aires ajout√©e.")
        if superpositions.featureCount() > 0:
            QgsProject.instance().addMapLayer(superpositions)
            print("‚úÖ Couche des superpositions ajout√©e.")
        if auto_intersections.featureCount() > 0:
            QgsProject.instance().addMapLayer(auto_intersections)
            print("‚úÖ Couche des auto-intersections ajout√©e.")

        # R√©sum√© des r√©sultats
        if all(layer.featureCount() == 0 for layer in [doublons_pontuels, doublons_lin√©aires, superpositions, auto_intersections]):
            print("‚úÖ Aucune erreur d√©tect√©e.")





    
    def geominvetnull(self):
        # D√©finition des couches
        couches = {
            "Canalisations": self.dlg.mMapLayerComboBox.currentLayer(),
            "Lin√©aires de branchement": self.dlg.mMapLayerComboBox_2.currentLayer(),
        }
        couches_points = {
            "Bo√Ætes de branchement": self.dlg.mMapLayerComboBox_5.currentLayer(),
            "Regards": self.dlg.mMapLayerComboBox_3.currentLayer(),
            "Ouvrages": self.dlg.mMapLayerComboBox_4.currentLayer(),
        } 

        # Cr√©ation des couches temporaires
        uri_lin_geom_inv = "LineString?crs=EPSG:2154"
        uri_pt_geom_inv = "Point?crs=EPSG:2154"
        
        geom_lin_invalides = QgsVectorLayer(uri_lin_geom_inv, "Lin√©aires_invalides", "memory")
        geom_pt_invalides = QgsVectorLayer(uri_pt_geom_inv, "Ponctuels_invalides", "memory")

        # Ajout des champs g√©n√©riques
        provider_lin = geom_lin_invalides.dataProvider()
        provider_pt = geom_pt_invalides.dataProvider()

        provider_lin.addAttributes([QgsField("couche", QVariant.String), QgsField("id", QVariant.Int)])
        provider_pt.addAttributes([QgsField("couche", QVariant.String), QgsField("id", QVariant.Int)])

        geom_lin_invalides.updateFields()
        geom_pt_invalides.updateFields()

        # V√©rification des g√©om√©tries lin√©aires
        for nom_couche, couche in couches.items():
            if not couche:
                print(f"La couche {nom_couche} n'est pas s√©lectionn√©e.")
                continue

            for feature in couche.getFeatures():
                geom = feature.geometry()
                if not geom or geom.isEmpty() or not geom.isGeosValid():  # ‚úÖ Utiliser isGeosValid()
                    new_feature = QgsFeature()
                    new_feature.setGeometry(geom)  
                    new_feature.setAttributes([nom_couche, feature.id()])
                    provider_lin.addFeature(new_feature)

        # V√©rification des g√©om√©tries ponctuelles
        for nom_couche, couche in couches_points.items():
            if not couche:
                print(f"La couche {nom_couche} n'est pas s√©lectionn√©e.")
                continue

            for feature in couche.getFeatures():
                geom = feature.geometry()
                if not geom or geom.isEmpty() or not geom.isGeosValid():  # ‚úÖ Utiliser isGeosValid()
                    new_feature = QgsFeature()
                    new_feature.setGeometry(geom)  
                    new_feature.setAttributes([nom_couche, feature.id()])
                    provider_pt.addFeature(new_feature)

        # Mise √† jour des couches
        geom_lin_invalides.updateExtents()
        geom_pt_invalides.updateExtents()

        # Ajouter les couches au projet QGIS
        if geom_lin_invalides.featureCount() > 0:
            QgsProject.instance().addMapLayer(geom_lin_invalides)
            print("‚úÖ Couche des lin√©aires invalides ajout√©e au projet.")
        if geom_pt_invalides.featureCount() > 0:
            QgsProject.instance().addMapLayer(geom_pt_invalides)
            print("‚úÖ Couche des ponctuels invalides ajout√©e au projet.")

        # Affichage des r√©sultats
        if geom_lin_invalides.featureCount() == 0 and geom_pt_invalides.featureCount() == 0:
            print("‚úÖ Toutes les g√©om√©tries sont valides.")





    def control1(self):
        canalisations = self.dlg.mMapLayerComboBox.currentLayer()
        linbranch = self.dlg.mMapLayerComboBox_2.currentLayer()
        boitesbranch = self.dlg.mMapLayerComboBox_5.currentLayer()

        branchements_isoles = []
        champs = linbranch.fields()  # R√©cup√©ration des champs de la couche d'origine

        # Cr√©ation de la couche temporaire
        uri = "LineString?crs=EPSG:2154"  # Modifie l'EPSG selon ton projet
        temp_layer = QgsVectorLayer(uri, "branchements_isoles", "memory")
        temp_layer.dataProvider().addAttributes(champs)  # Ajout des m√™mes champs que la couche originale
        temp_layer.updateFields()

        for branchement in linbranch.getFeatures():
            geom_branchement = branchement.geometry()

            if not geom_branchement or geom_branchement.isEmpty():
                continue

            if geom_branchement.isMultipart():
                line = geom_branchement.asMultiPolyline()[0]
            else:
                line = geom_branchement.asPolyline()

            if len(line) < 2:
                continue

            start_point = QgsGeometry.fromPointXY(line[0])  # Point amont
            end_point = QgsGeometry.fromPointXY(line[-1])  # Point aval

            # V√©rifier si l'amont touche une canalisation
            start_intersecte_cana = any(start_point.intersects(canalisation.geometry()) for canalisation in canalisations.getFeatures())
            # V√©rifier si l'aval touche une bo√Æte de branchement
            end_intersecte_boite = any(end_point.intersects(boite.geometry()) for boite in boitesbranch.getFeatures())

            # V√©rifier si l'aval touche une canalisation
            end_intersecte_cana = any(end_point.intersects(canalisation.geometry()) for canalisation in canalisations.getFeatures())
            # V√©rifier si l'amont touche une bo√Æte de branchement
            start_intersecte_boite = any(start_point.intersects(boite.geometry()) for boite in boitesbranch.getFeatures())

            # V√©rification finale : Amont doit toucher canalisation et aval bo√Æte, ou inversement
            branchement_valide = (start_intersecte_cana and end_intersecte_boite) or (end_intersecte_cana and start_intersecte_boite)

            if not branchement_valide:
                branchements_isoles.append(branchement.id())

                # Ajouter l'entit√© √† la couche temporaire
                new_feature = QgsFeature()
                new_feature.setGeometry(geom_branchement)
                new_feature.setAttributes(branchement.attributes())  # Copie les attributs
                temp_layer.dataProvider().addFeature(new_feature)

        temp_layer.updateExtents()

        # Ajouter la couche au projet QGIS
        QgsProject.instance().addMapLayer(temp_layer)

        # Affichage des r√©sultats
        if branchements_isoles:
            print(f"Lin√©aires de branchement isol√©s : {branchements_isoles}")
        else:
            print("Tous les branchements sont correctement connect√©s.")



    def control2(self):
        canalisations = self.dlg.mMapLayerComboBox.currentLayer()
        regards = self.dlg.mMapLayerComboBox_3.currentLayer()

        if not regards or not canalisations:
            print("Erreur : V√©rifiez que les couches sont bien s√©lectionn√©es.")
            return

        regards_isoles = []
        champs_reg = regards.fields()  # R√©cup√©ration des champs de la couche d'origine

        # Cr√©ation de la couche temporaire pour stocker les regards isol√©s
        uri_reg = "Point?crs=EPSG:2154"  # Modifier l'EPSG selon ton projet
        temp_layer_reg = QgsVectorLayer(uri_reg, "regards_isol√©s", "memory")
        provider = temp_layer_reg.dataProvider()
        provider.addAttributes(champs_reg)  # Ajout des m√™mes champs que la couche originale
        temp_layer_reg.updateFields()

        # Parcourir tous les regards
        for regard in regards.getFeatures():
            geom_regard = regard.geometry()

            if not geom_regard or geom_regard.isEmpty():
                continue

            est_connecte = False  # Flag pour v√©rifier si le regard est connect√© √† une canalisation

            # V√©rifier si ce regard est √† l'extr√©mit√© d'une canalisation
            for canalisation in canalisations.getFeatures():
                geom_canalisation = canalisation.geometry()

                if not geom_canalisation or geom_canalisation.isEmpty():
                    continue

                if geom_canalisation.isMultipart():
                    line = geom_canalisation.asMultiPolyline()[0]
                else:
                    line = geom_canalisation.asPolyline()

                if len(line) < 2:
                    continue

                cana_start_point = QgsGeometry.fromPointXY(line[0])
                cana_end_point = QgsGeometry.fromPointXY(line[-1])

                # V√©rification si le regard intersecte une des extr√©mit√©s de la canalisation
                if geom_regard.intersects(cana_start_point) or geom_regard.intersects(cana_end_point):
                    est_connecte = True
                    break  # Sortir d√®s qu'on trouve une connexion

            if not est_connecte:
                regards_isoles.append(regard.id())

                # Ajouter l'entit√© √† la couche temporaire
                new_feature = QgsFeature()
                new_feature.setGeometry(geom_regard)
                new_feature.setAttributes(regard.attributes())  # Copie les attributs
                provider.addFeature(new_feature)

        temp_layer_reg.updateExtents()

        # Ajouter la couche au projet QGIS
        QgsProject.instance().addMapLayer(temp_layer_reg)

        # Affichage des r√©sultats
        if regards_isoles:
            print(f"Regards isol√©s : {regards_isoles}")
        else:
            print("Tous les regards sont connect√©s √† une canalisation.")



    def boiteisoles(self):
        linbranch = self.dlg.mMapLayerComboBox_2.currentLayer()
        boitesbranch = self.dlg.mMapLayerComboBox_5.currentLayer()

        if not boitesbranch or not linbranch:
            print("Erreur : V√©rifiez que les couches sont bien s√©lectionn√©es.")
            return

        bbisoles = []
        champs_bb = boitesbranch.fields()  # R√©cup√©ration des champs de la couche d'origine

        # Cr√©ation de la couche temporaire pour stocker les bo√Ætes isol√©es
        uri_bb = "Point?crs=EPSG:2154"  # Adapter l'EPSG au projet
        temp_layer_bb = QgsVectorLayer(uri_bb, "boites_isolees", "memory")
        provider = temp_layer_bb.dataProvider()
        provider.addAttributes(champs_bb)  # Ajout des m√™mes champs que la couche originale
        temp_layer_bb.updateFields()

        # Parcourir toutes les bo√Ætes de branchement
        for boite in boitesbranch.getFeatures():
            geom_boite = boite.geometry()

            if not geom_boite or geom_boite.isEmpty():
                continue

            est_connecte = False  # Flag pour v√©rifier si la bo√Æte est connect√©e √† une canalisation de branchement

            # V√©rifier si la bo√Æte est √† l'extr√©mit√© d'une canalisation de branchement
            for lineaire_branchement in linbranch.getFeatures():
                geom_lineaire_branchement = lineaire_branchement.geometry()

                if not geom_lineaire_branchement or geom_lineaire_branchement.isEmpty():
                    continue

                if geom_lineaire_branchement.isMultipart():
                    line = geom_lineaire_branchement.asMultiPolyline()[0]
                else:
                    line = geom_lineaire_branchement.asPolyline()

                if len(line) < 2:
                    continue

                cana_start_point = QgsGeometry.fromPointXY(line[0])
                cana_end_point = QgsGeometry.fromPointXY(line[-1])

                # V√©rification si la bo√Æte intersecte une des extr√©mit√©s de la canalisation de branchement
                if geom_boite.intersects(cana_start_point) or geom_boite.intersects(cana_end_point):
                    est_connecte = True
                    break  # Sortir d√®s qu'on trouve une connexion

            if not est_connecte:
                bbisoles.append(boite.id())

                # Ajouter l'entit√© √† la couche temporaire
                new_feature = QgsFeature()
                new_feature.setGeometry(geom_boite)
                new_feature.setAttributes(boite.attributes())  # Copie les attributs
                provider.addFeature(new_feature)

        temp_layer_bb.updateExtents()

        # Ajouter la couche au projet QGIS
        if bbisoles:
            QgsProject.instance().addMapLayer(temp_layer_bb)
            print(f"‚úÖ {len(bbisoles)} bo√Ætes isol√©es d√©tect√©es et ajout√©es √† la carte.")
        else:
            print("‚úÖ Toutes les bo√Ætes de branchement sont connect√©es √† une canalisation.")



        


    def control3(self):
        canalisations = self.dlg.mMapLayerComboBox.currentLayer()

        if not canalisations:
            print("Erreur : Veuillez s√©lectionner une couche de canalisations.")
            return

        canalisations_isol√©es = []
        champs_cana = canalisations.fields()  # R√©cup√©ration des champs de la couche originale

        # Cr√©ation de la couche temporaire pour stocker les canalisations isol√©es
        uri_cana = "LineString?crs=EPSG:2154"  # Modifier l'EPSG selon le projet
        temp_layer_cana = QgsVectorLayer(uri_cana, "canalisations_isol√©es", "memory")
        provider = temp_layer_cana.dataProvider()
        provider.addAttributes(champs_cana)  # Copie les champs
        temp_layer_cana.updateFields()

        # Stocker les extr√©mit√©s des canalisations sous forme de dictionnaire {id: (start_point, end_point)}
        extremites_cana = {}

        for canalisation in canalisations.getFeatures():
            geom_cana = canalisation.geometry()
            
            if not geom_cana or geom_cana.isEmpty():
                continue

            if geom_cana.isMultipart():
                line = geom_cana.asMultiPolyline()[0]
            else:
                line = geom_cana.asPolyline()

            if len(line) < 2:
                continue

            cana_start_point = QgsGeometry.fromPointXY(line[0])
            cana_end_point = QgsGeometry.fromPointXY(line[-1])

            extremites_cana[canalisation.id()] = (cana_start_point, cana_end_point)

        # V√©rification de la connexion des extr√©mit√©s entre les canalisations
        for cana_id, (start_geom, end_geom) in extremites_cana.items():
            est_connecte = False

            for autre_id, (autre_start, autre_end) in extremites_cana.items():
                if cana_id == autre_id:
                    continue  # Ne pas comparer une canalisation avec elle-m√™me

                # V√©rifier si une extr√©mit√© touche une extr√©mit√© d'une autre canalisation
                if start_geom.intersects(autre_start) or start_geom.intersects(autre_end) or \
                end_geom.intersects(autre_start) or end_geom.intersects(autre_end):
                    est_connecte = True
                    break  # Pas besoin de continuer √† v√©rifier cette canalisation

            if not est_connecte:
                canalisations_isol√©es.append(cana_id)

                # Ajouter l'entit√© √† la couche temporaire
                new_feature = QgsFeature()
                new_feature.setGeometry(canalisations.getFeature(cana_id).geometry())
                new_feature.setAttributes(canalisations.getFeature(cana_id).attributes())  # Copie les attributs
                provider.addFeature(new_feature)

        temp_layer_cana.updateExtents()

        # Ajouter la couche au projet QGIS
        QgsProject.instance().addMapLayer(temp_layer_cana)

        # Affichage des r√©sultats
        if canalisations_isol√©es:
            print(f"Canalisations isol√©es : {canalisations_isol√©es}")
        else:
            print("Toutes les canalisations sont connect√©es.")

            



    def ecoulement(self):
        """V√©rifie le sens d'√©coulement des canalisations en fonction du champ radier des regards."""
        canalisations = self.dlg.mMapLayerComboBox.currentLayer()
        regards = self.dlg.mMapLayerComboBox_3.currentLayer()
        cote_rad = self.dlg.mFieldComboBox.currentField()  # Champ radier s√©lectionn√©
        id_cana = self.dlg.mFieldComboBox_2.currentField()  # Identifiant unique des canalisations

        if not canalisations or not regards or not cote_rad or not id_cana:
            print("Erreur : V√©rifiez que toutes les couches et champs sont bien s√©lectionn√©s.")
            return

        cana_mal_oriente = []
        champs_cana = canalisations.fields()  # R√©cup√©ration des champs de la couche originale

        # Cr√©ation de la couche temporaire pour stocker les canalisations avec un mauvais sens d'√©coulement
        uri_cana_ecoulement = "LineString?crs=EPSG:2154"  # Modifier l'EPSG selon le projet
        temp_layer_cana = QgsVectorLayer(uri_cana_ecoulement, "ecoulement_incorrect", "memory")
        provider = temp_layer_cana.dataProvider()
        provider.addAttributes(champs_cana)  # Copie les champs
        temp_layer_cana.updateFields()

        # Stocker les extr√©mit√©s des canalisations sous forme de dictionnaire {id: (start_point, end_point)}
        extremites_cana = {}

        for canalisation in canalisations.getFeatures():
            geom_cana = canalisation.geometry()

            if not geom_cana or geom_cana.isEmpty():
                continue

            if geom_cana.isMultipart():
                line = geom_cana.asMultiPolyline()[0]
            else:
                line = geom_cana.asPolyline()

            if len(line) < 2:
                continue

            cana_start_point = QgsGeometry.fromPointXY(line[0])
            cana_end_point = QgsGeometry.fromPointXY(line[-1])

            extremites_cana[canalisation[id_cana]] = (cana_start_point, cana_end_point)

        # V√©rifier le sens d'√©coulement en croisant les extr√©mit√©s avec les regards
        for canalisation_id, (start_geom, end_geom) in extremites_cana.items():
            radier_amont = None
            radier_aval = None

            for regard in regards.getFeatures():
                regard_geom = regard.geometry()

                if regard_geom and not regard_geom.isEmpty():
                    if start_geom.intersects(regard_geom):
                        radier_amont = regard[cote_rad]
                    elif end_geom.intersects(regard_geom):
                        radier_aval = regard[cote_rad]

            if radier_amont is not None and radier_aval is not None:
                if radier_amont < radier_aval:  # Sens d'√©coulement incorrect
                    cana_mal_oriente.append(canalisation_id)

        # Ajouter les canalisations mal orient√©es √† la couche temporaire
        for canalisation in canalisations.getFeatures():
            if canalisation[id_cana] in cana_mal_oriente:
                new_feature = QgsFeature()
                new_feature.setGeometry(canalisation.geometry())
                new_feature.setAttributes(canalisation.attributes())  # Copie les attributs
                provider.addFeature(new_feature)

        temp_layer_cana.updateExtents()

        # Ajouter la couche au projet QGIS
        QgsProject.instance().addMapLayer(temp_layer_cana)

        # Affichage des r√©sultats
        if cana_mal_oriente:
            print(f"Canalisations mal orient√©es : {cana_mal_oriente}")
        else:
            print("Toutes les canalisations respectent le sens d'√©coulement.")


    def update_field_list(self):
        """Met √† jour QListWidget avec les champs de la couche s√©lectionn√©e"""
        
        layer_classe = self.dlg.mMapLayerComboBox_6.currentLayer()
        
        if not layer_classe:
            print("Erreur : Aucune couche s√©lectionn√©e.")
            return
        
        # Vider la liste avant de la remplir √† nouveau
        self.dlg.listWidget.clear()

        # Ajouter les noms de champs
        for field in layer_classe.fields():
            item = QListWidgetItem(field.name())  # Cr√©er un √©l√©ment de liste
            item.setCheckState(Qt.Unchecked)  # Permet de cocher/d√©cocher les champs
            self.dlg.listWidget.addItem(item)

        print(f"üìå {self.dlg.listWidget.count()} champs affich√©s dans QListWidget.")

    
    def set_attributes(self):
        # Vider la liste des attributs affich√©s
        self.dlg.attributes.clear()

        # R√©cup√©rer la couche s√©lectionn√©e
        couche_classe_a = self.dlg.mMapLayerComboBox_6.currentLayer()

        if couche_classe_a is None:
            return  # Sortir si aucune couche s√©lectionn√©e

        # Ajouter les noms des champs au widget QListWidget ou QComboBox
        for field in couche_classe_a.fields():
            self.dlg.attributes.addItem(field.name())  # Assure-toi que `attributes` est d√©fini

        # V√©rifier le s√©parateur d√©cimal selon la locale
        if self.locale().decimalPoint() == '.':
            self.dlg.decimal_mark.setCurrentIndex(self.dlg.decimal_mark.findText("(period)"))
            self.dlg.field_delimiter.setCurrentIndex(self.dlg.field_delimiter.findText("(comma)"))
        else:
            self.dlg.decimal_mark.setCurrentIndex(self.dlg.decimal_mark.findText("(comma)"))
            self.dlg.field_delimiter.setCurrentIndex(self.dlg.field_delimiter.findText("(semicolon)"))















        
    def run_all_controls(self):
        self.control1()
        self.control2()
        self.control3()
        self.geominvetnull()
        self.doublongeom()
        self.set_attributes()
        self.dlg.mMapLayerComboBox_6.currentIndexChanged.connect(self.set_attributes)


    def run(self):
        """Run method that performs all the real work"""
        #self.dlg.mMapLayerComboBox_6.currentIndexChanged.connect(self.update_field_list)

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = demoiraDialog()

            # Connexion apr√®s la cr√©ation de l'interface
            self.dlg.but.clicked.connect(self.control1)
            self.dlg.but_2.clicked.connect(self.control2)
            self.dlg.but_3.clicked.connect(self.control3)
            self.dlg.but_4.clicked.connect(self.geominvetnull)
            self.dlg.but_5.clicked.connect(self.doublongeom)
            self.dlg.ecoul.clicked.connect(self.ecoulement)
            #self.dlg.classe.clicked.connect(self.verifclassea)

            # Ex√©cuter tous les controles 
            self.dlg.allcontrol.clicked.connect(self.run_all_controls)

        self.dlg.but.setEnabled(True)
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass



